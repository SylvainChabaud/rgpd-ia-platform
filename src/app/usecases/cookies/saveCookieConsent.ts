import type { CookieConsentRepo } from '@/app/ports/CookieConsentRepo';
import type { AuditEventWriter } from '@/app/ports/AuditEventWriter';
import type { CookieConsent } from '@/domain/legal/CookieConsent';
import { createCookieConsent } from '@/domain/legal/CookieConsent';
import { emitAuditEvent } from '@/app/audit/emitAuditEvent';
import { randomUUID } from 'crypto';
import { ACTOR_SCOPE } from '@/shared/actorScope';

/**
 * Save cookie consent use-case
 *
 * RGPD compliance:
 * - ePrivacy Directive 2002/58/CE Art. 5.3
 * - Supports both authenticated users and anonymous visitors
 * - Necessary cookies always TRUE (non-modifiable)
 * - TTL 12 months (CNIL standard)
 * - Audit event emitted (P1 data only, no PII)
 * - Updates existing consent instead of creating duplicates
 *
 * LOT 10.3 â€” Cookie Consent Banner
 */

export type SaveCookieConsentInput = {
  tenantId?: string;
  userId?: string;
  anonymousId?: string;
  analytics: boolean;
  marketing: boolean;
  ipAddress?: string;
  userAgent?: string;
};

export type SaveCookieConsentResult = {
  consent: CookieConsent;
};

export async function saveCookieConsent(
  consentRepo: CookieConsentRepo,
  auditWriter: AuditEventWriter,
  input: SaveCookieConsentInput
): Promise<SaveCookieConsentResult> {
  // Validation: soit userId, soit anonymousId (pas les deux)
  if (!input.userId && !input.anonymousId) {
    throw new Error('Either userId or anonymousId is required');
  }
  if (input.userId && input.anonymousId) {
    throw new Error('Cannot have both userId and anonymousId');
  }

  // Validate via domain factory (business rules)
  createCookieConsent({
    tenantId: input.tenantId,
    userId: input.userId,
    anonymousId: input.anonymousId,
    analytics: input.analytics,
    marketing: input.marketing,
    ipAddress: input.ipAddress,
    userAgent: input.userAgent,
  });

  // Check if consent already exists for this user/anonymous
  let existingConsent: CookieConsent | null = null;
  if (input.userId) {
    existingConsent = await consentRepo.findByUser(input.userId);
  } else if (input.anonymousId) {
    existingConsent = await consentRepo.findByAnonymousId(input.anonymousId);
  }

  let consent: CookieConsent;
  let isUpdate = false;

  if (existingConsent) {
    // Update existing consent
    consent = await consentRepo.update(existingConsent.id, {
      analytics: input.analytics,
      marketing: input.marketing,
    });
    isUpdate = true;
  } else {
    // Create new consent
    consent = await consentRepo.save({
      tenantId: input.tenantId,
      userId: input.userId,
      anonymousId: input.anonymousId,
      analytics: input.analytics,
      marketing: input.marketing,
      ipAddress: input.ipAddress,
      userAgent: input.userAgent,
    });
  }

  // Emit audit event (RGPD-safe: P1 data only, no PII)
  // Note: For anonymous users, use consent ID as actorId (audit_events.actor_id is UUID)
  // The consent.id is a valid UUID generated by the repository
  await emitAuditEvent(auditWriter, {
    id: randomUUID(),
    eventName: isUpdate ? 'cookies.consent.updated' : 'cookies.consent.created',
    actorScope: input.tenantId ? ACTOR_SCOPE.TENANT : ACTOR_SCOPE.PLATFORM,
    actorId: input.userId ?? consent.id, // Use consent ID for anonymous (valid UUID)
    tenantId: input.tenantId ?? undefined,
    metadata: {
      analytics: input.analytics,
      marketing: input.marketing,
      isAnonymous: !input.userId,
      isUpdate,
    },
  });

  return { consent };
}
